############################################################
# HonestDiD-style Hybrid vs OLS plot (single panel)
# Greenstone & Hanna–like PT violation
# Restrictions: Monotonicity + Post-sign + RM(level)
############################################################

## 0) Packages
req <- c("fixest","data.table","ggplot2","Matrix","broom","lpSolve","remotes")
new <- req[!(req %in% installed.packages()[,"Package"])]
if(length(new)) install.packages(new, dependencies = TRUE)

if (!requireNamespace("HonestDiD", quietly = TRUE)) {
  remotes::install_github("asheshrambachan/HonestDiD", force = TRUE)
}

suppressPackageStartupMessages({
  library(fixest); library(data.table); library(ggplot2)
  library(Matrix); library(broom); library(lpSolve)
  ok_HD <- requireNamespace("HonestDiD", quietly = TRUE)
  if (ok_HD) library(HonestDiD)
})

set.seed(12345)

## 1) DGP
N_treat <- 140; N_control <- 140; N <- N_treat + N_control
preT <- 5; postT <- 6
ev_times <- -preT:postT

DT <- CJ(id = 1:N, t = ev_times)
DT[, treat := as.integer(id <= N_treat)]
DT[, ai := rnorm(N, 0, 0.6)[id]]
DT[, g_t := 0.03 * t]

delta_fun <- function(tt) 0.18 * (tt + preT) # monotone upward bias
DT[, delta_bias := ifelse(treat==1, delta_fun(t), 0)]

tau_true <- -0.35
DT[, tau_it := ifelse(treat==1 & t>=0, tau_true, 0)]
DT[, eps := rnorm(.N, 0, 0.45)]
DT[, Y := ai + g_t + delta_bias + tau_it + eps]

## 2) Event study
es_fit <- feols(Y ~ i(t, treat, ref = -1) | id + t, data = DT)
all_times <- setdiff(ev_times, -1)
cn <- paste0("t::", all_times, ":treat")
cn <- cn[cn %in% names(es_fit$coefficients)]

betahat <- as.numeric(es_fit$coefficients[cn]); names(betahat) <- cn
Sigma   <- as.matrix(vcov(es_fit, se = "hetero")[cn, cn, drop=FALSE])

pre_idx  <- which(all_times < 0)
post_idx <- which(all_times >= 0)
betahat_pre   <- betahat[pre_idx]
betahat_post  <- betahat[post_idx]
Sigma_pre     <- Sigma[pre_idx,  pre_idx,  drop=FALSE]
Sigma_post    <- Sigma[post_idx, post_idx, drop=FALSE]
Sigma_pp      <- Sigma[pre_idx,  post_idx, drop=FALSE]
Sigma_ppt     <- t(Sigma_pp)

numPre  <- length(pre_idx)
numPost <- length(post_idx)
pre_times  <- sort(all_times[pre_idx])
post_times <- sort(all_times[post_idx])
Ttot <- numPre + numPost

## 3) Constraints: monotonicity + sign + anchor + box + RM(level)
pos <- function(tt) if (tt < 0) which(pre_times == tt) else numPre + which(post_times == tt)

build_base <- function(Bbox = 25) {
  A <- list(); d <- list()
  ord <- c(pre_times, post_times)
  for (k in 1:(length(ord)-1)) {
    i1 <- pos(ord[k]); i2 <- pos(ord[k+1])
    a <- rep(0, Ttot); a[i2] <- -1; a[i1] <- +1
    A[[length(A)+1]] <- a; d[[length(d)+1]] <- 0
  }
  j <- pos(max(pre_times)); a <- rep(0, Ttot); a[j] <- +1
  A[[length(A)+1]] <- a; d[[length(d)+1]] <- 0
  for (tt in post_times) { i <- pos(tt); a <- rep(0, Ttot); a[i] <- -1
  A[[length(A)+1]] <- a; d[[length(d)+1]] <- 0 }
  for (j in seq_len(Ttot)) {
    a <- rep(0, Ttot); a[j] <- +1; A[[length(A)+1]] <- a; d[[length(d)+1]] <- Bbox
    a <- rep(0, Ttot); a[j] <- -1; A[[length(A)+1]] <- a; d[[length(d)+1]] <- Bbox
  }
  list(A = do.call(rbind, A), d = unlist(d))
}

add_RM_level_caps <- function(A, d, Mbar) {
  max_pre_level_abs <- suppressWarnings(max(abs(as.numeric(betahat_pre)), na.rm = TRUE))
  if (!is.finite(max_pre_level_abs) || max_pre_level_abs <= 0) max_pre_level_abs <- 0.05
  cap <- Mbar * max_pre_level_abs
  B <- list(); e <- list()
  for (tt in post_times) {
    i <- pos(tt)
    a <- rep(0, Ttot); a[i] <- +1; B[[length(B)+1]] <- a; e[[length(e)+1]] <- cap
  }
  list(A = rbind(A, do.call(rbind, B)), d = c(d, unlist(e)))
}

## 4) Target: ATT at t = +2
l_vec <- as.numeric(post_times == 2L)

ols_ci <- function(l_vec){
  est <- sum(l_vec * betahat_post)
  v   <- as.numeric(t(l_vec) %*% Sigma_post %*% l_vec)
  se  <- sqrt(max(v,0))
  c(est - 1.96*se, est + 1.96*se)
}
ols_bounds <- ols_ci(l_vec)

## 5) Compute Hybrid CS across Mbar
base <- build_base()
Mgrid <- c(0.5, 1.0, 1.5, 2.0)

use_poly <- ok_HD && ("createSensitivityResults_polyhedral" %in% getNamespaceExports("HonestDiD"))

compute_CS <- function(l_vec, A, d) {
  if (use_poly) {
    beta_full <- c(betahat_pre[order(pre_times)], betahat_post[order(post_times)])
    Sigma_full <- rbind(
      cbind(Sigma_pre[order(pre_times),  order(pre_times),  drop=FALSE],
            Sigma_pp [order(pre_times),  order(post_times), drop=FALSE]),
      cbind(Sigma_ppt[order(post_times), order(pre_times),  drop=FALSE],
            Sigma_post[order(post_times), order(post_times), drop=FALSE])
    )
    out <- HonestDiD::createSensitivityResults_polyhedral(
      betahat = beta_full, sigma = Sigma_full,
      numPrePeriods = numPre, numPostPeriods = numPost,
      l_vec = l_vec, A = A, d = d,
      alpha = 0.05, hybrid_flag = TRUE
    )
    unname(out$Confidence.Set)
  } else {
    # LP fallback
    cvec <- c(rep(0, numPre), l_vec)
    smax <- lp("max", cvec, A, rep("<=", nrow(A)), d)
    smin <- lp("min", cvec, A, rep("<=", nrow(A)), d)
    theta_hat <- sum(l_vec * betahat_post)
    c(theta_hat - smax$objval, theta_hat - smin$objval)
  }
}

rows <- lapply(Mgrid, function(M){
  Om <- add_RM_level_caps(base$A, base$d, M)
  cs <- compute_CS(l_vec, Om$A, Om$d)
  data.frame(Mbar = M, LB = cs[1], UB = cs[2])
})
df <- do.call(rbind, rows)

## 6) Plot (RR style, single panel)
x_ols <- min(Mgrid) - 0.25
p <- ggplot() +
  geom_linerange(data = df, aes(x = Mbar, ymin = LB, ymax = UB, color = "Hybrid"), linewidth = 1.1) +
  geom_linerange(data = data.frame(Mbar = x_ols, LB = ols_bounds[1], UB = ols_bounds[2]),
                 aes(x = Mbar, ymin = LB, ymax = UB, color = "OLS"), linewidth = 1.1) +
  geom_hline(yintercept = 0, linewidth = 0.4) +
  scale_color_manual(values = c("Hybrid"="#E41A1C","OLS"="#1F9AFE")) +
  scale_x_continuous(breaks = c(x_ols, Mgrid), labels = c(" ", Mgrid)) +
  labs(title = expression(paste("Sensitivity: ", theta," = ", tau["+2"])),
       x = expression(bar(M)), y = NULL, color = NULL) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "bottom", plot.title = element_text(hjust = 0.5))
print(p)

## 7) Breakdown value (smallest M where CI covers 0)
df$contains_zero <- (df$LB <= 0 & df$UB >= 0)
breakdown <- min(df$Mbar[df$contains_zero])
cat("Breakdown value Mbar ≈", breakdown, "\n")
