###############################################################
# HonestDiD RM sensitivity (C-LF style) for Ashenfelter’s Dip
# - Dip at t = -1
# - Miller (2023) Fix A: reference = -4:-2 (exclude -1)
# - l_vec over POST periods only (τ1)
# - Sensitivity computed by HonestDiD, plotted via ggplot (C-LF look)
###############################################################

## Packages
req <- c("data.table","fixest","HonestDiD","broom","ggplot2")
new <- req[!(req %in% installed.packages()[,"Package"])]
if (length(new)) install.packages(new, dependencies = TRUE)

suppressPackageStartupMessages({
  library(data.table)
  library(fixest)
  library(HonestDiD)
  library(broom)
  library(ggplot2)
})

set.seed(12345)

## 1) DGP with Ashenfelter’s dip at t = -1
TT_pre  <- 5        # pre: -5..-1
TT_post <- 5        # post: 0..4
t_grid  <- -TT_pre:(TT_post-1)
N_treat <- 100
N_ctrl  <- 100
N       <- N_treat + N_ctrl
treat_start <- 0

DT <- CJ(id = 1:N, time = t_grid)
DT[, treated := (id <= N_treat)]

# Unit and time fixed effects
alpha_i <- rnorm(N, 0, 1)
DT[, fe_i := alpha_i[id]]
DT[, fe_t := 0.10 * time]

# AR(1) noise as numeric (avoid 'ts' objects)
sim_ar1_numeric <- function(Tlen, rho = 0.3, sigma = 1) {
  e <- rnorm(Tlen, 0, sigma); x <- numeric(Tlen)
  x[1] <- e[1] / sqrt(1 - rho^2)
  for (t in 2:Tlen) x[t] <- rho * x[t-1] + e[t]
  x
}
DT[, eps := sim_ar1_numeric(length(t_grid)), by = id]

# Treatment path and the dip at -1
tau_val <- 0.6
DT[, post := as.integer(time >= treat_start)]
DT[, te   := ifelse(treated & post == 1, tau_val, 0)]

dip_mag <- -1.8
DT[, dip := ifelse(treated & time == -1, dip_mag, 0)]

# Outcome and event time
DT[, y := fe_i + fe_t + eps + te + dip]
DT[, event_time := time - treat_start]  # IMPORTANT: name exactly 'event_time'

## 2) Miller Fix A: reference window excludes -1
ref_win <- c(-4, -3, -2)

## 3) Event study with fixest
es_fit <- feols(
  y ~ i(event_time, treated, ref = ref_win) | id + time,
  data = DT
)

## 4) Extract ES ingredients for HonestDiD (robust to version)
hd_ns  <- asNamespace("HonestDiD")
hasfun <- function(f) exists(f, where = hd_ns, inherits = FALSE)

if (hasfun("extract_es")) {
  es_obj          <- HonestDiD::extract_es(es_fit)
  betahat_es      <- es_obj$betahat
  Sigma_es        <- es_obj$sigma
  numPrePeriods   <- es_obj$numPrePeriods
  numPostPeriods  <- es_obj$numPostPeriods
  eventTimes      <- es_obj$eventTimes
} else {
  # Fallback parser for fixest 0.12.x term names
  co <- broom::tidy(es_fit)
  get_k <- function(term) {
    pats <- c("^event_time::(-?\\d+):treated$",
              "^i\\(event_time,\\s*treated[^)]*\\)::(-?\\d+)$",
              "^.*::(-?\\d+):treated$")
    for (p in pats) {
      m <- regexec(p, term); r <- regmatches(term, m)[[1]]
      if (length(r) >= 2 && !is.na(r[2])) return(as.integer(r[2]))
    }
    NA_integer_
  }
  co$k <- vapply(co$term, get_k, 1L)
  co   <- co[!is.na(co$k), ]
  co   <- co[order(co$k), ]
  eventTimes      <- co$k
  numPrePeriods   <- sum(eventTimes < 0)
  numPostPeriods  <- sum(eventTimes >= 0)
  betahat_es      <- co$estimate
  
  V <- vcov(es_fit, se = "hetero")
  keep <- rownames(V) %in% co$term
  V <- V[keep, keep, drop = FALSE]
  rn <- rownames(V); ord <- match(co$term, rn)
  Sigma_es <- V[ord, ord, drop = FALSE]
}

## 5) Build l_vec over POST periods only (target = τ1)
post_times <- eventTimes[eventTimes >= 0]   # e.g., 0,1,2,3,4
l_vec_tau1 <- rep(0, numPostPeriods)
p1 <- which(post_times == 1)
if (length(p1) != 1) stop("event_time == 1 (τ1) not found among POST periods.")
l_vec_tau1[p1] <- 1

## 6) HonestDiD constructor wrapper (handles Mvec/Mbar/MbarVec/type)
ctor_candidates  <- c("createSensitivityResults_relativeMagnitudes",
                      "createSensitivityResults_relativeMagnitude",
                      "createSensitivityResults")
pick_fun <- function(cands) { for (f in cands) if (hasfun(f)) return(get(f, envir = hd_ns)); NULL }
ctor_fun <- pick_fun(ctor_candidates)
if (is.null(ctor_fun)) stop("HonestDiD sensitivity constructor not found.")

Mgrid <- seq(0, 2, by = 0.1)

call_ctor <- function(lv) {
  base <- list(betahat = betahat_es, sigma = Sigma_es,
               numPrePeriods = numPrePeriods, numPostPeriods = numPostPeriods,
               l_vec = lv)
  fmls <- names(formals(ctor_fun))
  if ("Mvec" %in% fmls)        base$Mvec    <- Mgrid
  else if ("MbarVec" %in% fmls) base$MbarVec <- Mgrid
  else if ("Mbar" %in% fmls)    base$Mbar    <- Mgrid
  if ("type" %in% fmls)         base$type    <- "relative_magnitude"
  suppressWarnings(do.call(ctor_fun, base))
}
sens_tau1 <- call_ctor(l_vec_tau1)

## 7) Tidy HonestDiD RM result into a data frame (M, lower, upper, point)
tidy_hd_rm <- function(obj, Mgrid) {
  # Collect all data.frames inside the object (recursively)
  dfs <- list()
  crawl <- function(x) {
    if (is.data.frame(x)) dfs[[length(dfs)+1]] <<- x
    else if (is.list(x)) for (nm in names(x)) crawl(x[[nm]])
  }
  crawl(obj)
  if (!length(dfs)) stop("Could not find a results data.frame inside the HonestDiD object.")
  
  pick <- NULL; Mcol <- Lcol <- Ucol <- Pcol <- NULL
  for (df in dfs) {
    cn <- tolower(names(df))
    m_idx <- which(cn %in% c("m","mbar","mvec","mbarvec","grid","m_grid"))
    if (!length(m_idx)) m_idx <- which(sapply(df, function(col) is.numeric(col) && any(round(col,6) %in% round(Mgrid,6))))
    if (length(m_idx)) {
      l_idx <- which(cn %in% c("cil","ci_lower","lower","lb","lower.ci"))
      u_idx <- which(cn %in% c("ciu","ci_upper","upper","ub","upper.ci"))
      p_idx <- which(cn %in% c("point.est","point","estimate","est","beta","betahat"))
      if (!length(l_idx) || !length(u_idx)) {
        l_idx <- c(l_idx, which(grepl("ci.*low", cn)))
        u_idx <- c(u_idx, which(grepl("ci.*up",  cn)))
      }
      if (length(l_idx) && length(u_idx)) {
        pick <- df; Mcol <- names(df)[m_idx[1]]
        Lcol <- names(df)[l_idx[1]]; Ucol <- names(df)[u_idx[1]]
        Pcol <- if (length(p_idx)) names(df)[p_idx[1]] else NULL
        break
      }
    }
  }
  if (is.null(pick)) stop("Could not identify M/CI columns in HonestDiD result.")
  data.frame(
    M     = as.numeric(pick[[Mcol]]),
    lower = as.numeric(pick[[Lcol]]),
    upper = as.numeric(pick[[Ucol]]),
    point = if (!is.null(Pcol)) as.numeric(pick[[Pcol]]) else NA_real_
  )
}
DF <- tidy_hd_rm(sens_tau1, Mgrid)

## 8) C-LF style plot (blue Original at M=0, red intervals for each M)
orig_row <- DF[which.min(abs(DF$M - 0)), , drop = FALSE]

p_clf <- ggplot() +
  geom_hline(yintercept = 0, color = "black") +
  # Red C-LF intervals for the sensitivity grid
  geom_errorbar(data = DF, aes(x = M, ymin = lower, ymax = upper),
                color = "red", width = 0.03, linewidth = 0.6) +
  # Blue "Original" interval at M=0
  geom_errorbar(data = orig_row,
                aes(x = M, ymin = lower, ymax = upper),
                color = "#5cc9d6", width = 0.06, linewidth = 1.2) +
  scale_x_continuous(name = "M̄ (relative-magnitude bound)",
                     breaks = seq(min(DF$M, na.rm = TRUE),
                                  max(DF$M, na.rm = TRUE), by = 0.5)) +
  labs(y = NULL, title = "HonestDiD RM Sensitivity (C-LF) for τ1") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none")

print(p_clf)

###############################################################
# To target avg(τ1..τ3) instead of τ1:
#   l_vec_avg <- rep(0, numPostPeriods)
#   for (k in 1:3) l_vec_avg[which(post_times == k)] <- l_vec_avg[which(post_times == k)] + 1/3
#   sens_avg <- call_ctor(l_vec_avg)
#   DF <- tidy_hd_rm(sens_avg, Mgrid)
#   then re-run the plotting block.
###############################################################
