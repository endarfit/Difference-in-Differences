###############################################################
# High-Power Canonical DiD + HonestDiD Smoothness (Δ^SD, C-LF)
# - Bigger N, lower noise, larger effect
# - Official Smoothness plot + dashed breakdown M
# - Output: sr_sensitivity_onimpact_highpower.png
###############################################################

## 0) Packages (install if missing) -------------------------------------------
req <- c("data.table","fixest","ggplot2","broom","HonestDiD")
new <- req[!(req %in% installed.packages()[,"Package"])]
if (length(new)) install.packages(new, dependencies = TRUE)

if (!requireNamespace("HonestDiD", quietly = TRUE)) {
  if (!requireNamespace("remotes", quietly = TRUE)) install.packages("remotes")
  remotes::install_github("asheshrambachan/HonestDiD")
}

suppressPackageStartupMessages({
  library(data.table)
  library(fixest)
  library(ggplot2)
  library(broom)
  library(HonestDiD)
})

set.seed(12345)

## 1) High-power design choices -----------------------------------------------
N           <- 3000
T_pre       <- 5
T_post      <- 5
sigma_alpha <- 0.5
sigma_eps   <- 0.5
trend_slope <- 0.0
tau_const   <- 2.0

true_tau_fun <- function(k) rep(tau_const, length(k))  # constant post ATT, 0 pre

## 2) DGP ----------------------------------------------------------------------
simulate_canonical_did <- function(N, T_pre, T_post, sigma_alpha, sigma_eps, trend_slope) {
  stopifnot(T_pre >= 2)
  t_vec <- seq(-T_pre, T_post - 1); TT <- length(t_vec)
  
  id <- 1:N
  treated_ids <- sample(id, size = round(0.5 * N), replace = FALSE)
  
  alpha_i  <- rnorm(N, 0, sigma_alpha)
  lambda_t <- rnorm(TT, 0, 0.5) + trend_slope * t_vec
  
  dt <- data.table(id = rep(id, each = TT), time = rep(t_vec, times = N))
  dt[, treated := as.integer(id %in% treated_ids)]
  dt[, alpha := alpha_i[id]]
  dt[, lambda := lambda_t[match(time, t_vec)]]
  dt[, event_time := time]
  
  K_post  <- 0:(T_post - 1)
  tau_map <- setNames(true_tau_fun(K_post), K_post)
  dt[, tau_true := 0]
  dt[treated == 1 & event_time %in% K_post, tau_true := tau_map[as.character(event_time)]]
  
  dt[, eps := rnorm(.N, 0, sigma_eps)]
  dt[, y := alpha + lambda + tau_true + eps]
  
  K_pre <- -T_pre:-2
  K_all <- c(K_pre, K_post)
  k_var <- function(k) if (k >= 0) sprintf("Dk_p%d", k) else sprintf("Dk_m%d", abs(k))
  for (k in K_all) dt[[k_var(k)]] <- as.integer(dt$treated == 1 & dt$event_time == k)
  
  list(dt = dt, K_pre = K_pre, K_post = K_post, K_all = K_all, k_var = k_var)
}

sim <- simulate_canonical_did(N, T_pre, T_post, sigma_alpha, sigma_eps, trend_slope)

## 3) Event-study via fixest ---------------------------------------------------
var_names <- vapply(sim$K_all, sim$k_var, character(1))
fml <- as.formula(paste0("y ~ ", paste(var_names, collapse = " + "), " | id + time"))
mod <- feols(fml, data = sim$dt, cluster = ~ id)

## 4) betahat & sigma in correct order ----------------------------------------
betahat_all <- coef(mod)
betahat     <- as.numeric(betahat_all[var_names])
V <- vcov(mod, cluster = "id")
sigma <- as.matrix(V[var_names, var_names])

numPrePeriods  <- length(sim$K_pre)
numPostPeriods <- length(sim$K_post)
alpha_level    <- 0.05

## 5) Estimand: τ0 (on-impact) -------------------------------------------------
l_onimpact <- HonestDiD::basisVector(index = 1, size = numPostPeriods)

## 6) HonestDiD Smoothness sensitivity (Δ^SD, C-LF) + plot ---------------------
Mvec <- seq(0, 5, by = 0.05)  # wider grid to reflect higher power

robustResults <- HonestDiD::createSensitivityResults(
  betahat        = betahat,
  sigma          = sigma,
  numPrePeriods  = numPrePeriods,
  numPostPeriods = numPostPeriods,
  method         = "C-LF",
  Mvec           = Mvec,
  l_vec          = l_onimpact,
  alpha          = alpha_level
)

originalResults <- HonestDiD::constructOriginalCS(
  betahat        = betahat,
  sigma          = sigma,
  numPrePeriods  = numPrePeriods,
  numPostPeriods = numPostPeriods,
  l_vec          = l_onimpact,
  alpha          = alpha_level
)

p_sr <- HonestDiD::createSensitivityPlot(
  robustResults   = robustResults,
  originalResults = originalResults,
  maxM            = max(Mvec)
)

## 7) Breakdown M (first M with CI containing 0) -------------------------------
rr <- robustResults
rr_clf <- rr[rr$method == "C-LF", , drop = FALSE]
contains_zero <- rr_clf$lb <= 0 & rr_clf$ub >= 0
M_break <- if (any(contains_zero)) rr_clf$M[which(contains_zero)[1]] else NA_real_
cat(sprintf("Smoothness breakdown M for τ0 (C-LF): %s\n",
            ifelse(is.na(M_break), "not within grid", round(M_break, 3))))

y_top <- max(c(rr$ub, originalResults$ub), na.rm = TRUE)
if (!is.na(M_break)) {
  p_sr <- p_sr +
    geom_vline(xintercept = M_break, linetype = "dashed") +
    annotate("text", x = M_break, y = y_top,
             label = paste0("Breakdown M = ", round(M_break, 2)),
             vjust = -0.5, size = 3)
}

## 8) Save ---------------------------------------------------------------------
ggsave("sr_sensitivity_onimpact_highpower.png", p_sr, width = 8, height = 5, dpi = 300)
cat('Saved "sr_sensitivity_onimpact_highpower.png"\n')
